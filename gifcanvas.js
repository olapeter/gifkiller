(function(){	document.addEventListener('load',		function(e){			var gif, w, h;			var t0 = window.performance.now();			if( e.target.nodeName=='IMG' && e.target.src.match(/.gif/) ){								gif = e.target;								w = parseInt( getComputedStyle(gif,null).getPropertyValue('width') );				h = parseInt( getComputedStyle(gif,null).getPropertyValue('height') );				if( w < 10 || h < 10 )return; //don't bother with small gifs												isAnimated(replaceImg)			}									function isAnimated(callback){								/*					Ideally one could do img.src = replaceImg()					but for x-domain images canvas becomes tainted 					and can't be exported with toDataURL.					https://code.google.com/p/chromium/issues/detail?id=161471										But from an extension we can do x-domain XHR, allowing to 					fetch the image again, placing it in an arraybuffer for inspection.										Downside is that .gifs are requested twice (though hopefully cached 					the second time :P )									*/								var xhr = new XMLHttpRequest();				xhr.open( 'GET' , gif.src , true);				xhr.responseType = 'arraybuffer';				xhr.onload = function(){					/* Routine from https://gist.github.com/camupod/3012623 + bugfix */					var arr = new Uint8Array(xhr.response), i, len, length = arr.length, frames = 0;										/* Is it a gif? */					if (arr[0] !== 0x47 || arr[1] !== 0x49 || arr[2] !== 0x46 || arr[3] !== 0x38){						callback(false);						return;					}										/* Look for frame delimiters */					for (i=0, len = length - 9; frames < 2 && i < len ; ++i) {						if (arr[i] === 0x00 && arr[i+1] === 0x21 &&	arr[i+2] === 0xF9 && arr[i+3] === 0x04 && arr[i+8] === 0x00 && (arr[i+9] === 0x2C || arr[i+9] === 0x21))						{							frames++;						}					}									/* if frame count > 1, it is animated */					callback(frames > 1);									}				xhr.send();			}						function replaceImg( isAnimated ){				if(!isAnimated)return;								var cnv = document.createElement('canvas');				cnv.width = w;				cnv.height = h;								/*					Could also copy all styles to be safer, but this will do for now 				*/				if( gif.className ) cnv.className = gif.className;				if( gif.id ) cnv.id = gif.id;								/* 					Save reference to original for click-to-play 				*/				cnv.setAttribute('data-orig-src' , gif.src);				cnv.addEventListener('dblclick' , playOriginal , false);								var ctx = cnv.getContext('2d');				ctx.drawImage( gif , 0 , 0 );								/* 					Play "button" overlay triangle				*/								ctx.fillStyle = 'rgba(99,99,99,0.5)';				ctx.strokeStyle = 'rgba(0,0,0,0.8)';				ctx.beginPath();				ctx.moveTo(w/3, h/3);				ctx.lineTo(w/3, 2*h/3);				ctx.lineTo(2*w/3,h/2);				ctx.lineTo(w/3, h/3);				ctx.fill();				ctx.stroke();				ctx.closePath();								/*					Replace original element with canvas.					See isAnimated comments for why not using gif.src=...				*/				gif.parentNode.replaceChild( cnv , gif );				console.log(gif.src + ' replacement time in ms: ' + (window.performance.now()-t0))			}						function playOriginal(e){				/*					Create a new document and place the original animation					in it for click-to-play in a pop-up.				*/				var cnv = e.target;				var osrc = cnv.getAttribute('data-orig-src');				var img = document.createElement('img');				img.src = osrc;				var btn = document.createElement('button');				btn.innerText = 'Close';				btn.setAttribute('onclick','window.close()');				var doc = document.implementation.createHTMLDocument('Original Animation');				doc.body.appendChild(img);				doc.body.appendChild(btn);				var url = 'data:text/html,'+doc.documentElement.outerHTML;				window.showModalDialog(url);			}							}	,true);})();